---
layout: blog
title: Looking Forward to Casablanca [1 of n]
excerpt: Those of you who know me, also know my appreciation for c++. Those of you knowing time cockpit will also know that nearly all of it is written in c#/.net with its service hosting infrastructure running in Windows Azure. There is one particular part of time cockpit that will, at some point in the future, receive a native rewrite and due to the nature of it, storing its data in windows azure is a key requirement. Windows Azure, up to now, does not offer a developer story for C++ development, especially considering access to its storage subsystem. This is where Casablanca comes in to play - 
author: Philipp Aumayr
date: 2012-10-03
bannerimage: 
bannerimagesource: 
lang: en
tags: [C]
ref: 
permalink: /devblog/2012/10/03/Looking-Forward-to-Casablanca-[1-of-n]
---

<h2>Table access using Casablanca</h2><p>So, today I finally got around to try out the recently refreshed bits and added them to a test project by adding an include directory to the include directory in the installation directory. The same for the library directory and finally I added the casablanca110.lib to the libraries to be linked. Since I was using the azure sdk for c# before, I knew what I as looking for and found a cloud_table_client class in the <strong>azure::storage</strong> namespace. Since for testing purposes I was going to use the development storage, I created the storage credentials with the standard development storage keys. Note that these can be found by using <strong>local_storage::credentials();</strong> and  <strong>local_storage::table_storage_uri()</strong> but I figured, I’d better look at what the final code will be like. So this is what I started with:</p>{% highlight cpp %}storage_credentials local_creds(U("devstoreaccount1"), U("Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw=="));
cloud_table_client ctc(http::uri(U("http://127.0.0.1:10002/devstoreaccount1/")), local_creds);{% endhighlight %}<h2>Creating a table</h2><p>Of course, the first thing I wanted to do, was to create a table (you wouldn’t guess what I’m playing with all the time from the name of the tables!). After some waiting for IntelliSense to build its database from the casablanca headers, I started looking at some constructors, and it became very obvious:</p>{% highlight cpp %}cloud_table ct(ctc, U("Signals"));
ct.create().get();{% endhighlight %}<p>Having looked at a bit of PPL (Parallel Patterns Library) code before, I knew it was a good idea to get the result, to assure it waits till the table was created. Eager to see results, I opened up the Server Explorer in Visual Studio and found my beloved Signals table:</p><p>
  <img src="{{site.baseurl}}/content/images/blog/2012/10/signals_table_server_explorer.PNG" />
</p><h2>Inserting</h2><p>Next, I wanted to fill the table with some data. Looking at the other methods in the <strong>cloud_table</strong> class  I found a winner: <strong>insert_entity(const cloud_table_entity &amp;)</strong>.  The .net SDK endorses a way of you deriving from <strong>TableServiceEntity</strong>, but I’m not to keen on deriving from a class just to fill some data, so I tried with <strong>cloud_table_entity</strong> directly. This is what I finally ended up with:</p>{% highlight cpp %}cloud_table_entity signal(U("Signals_Device"), U("21"));
ct.insert_entity(signal).get();{% endhighlight %}<p>“Well, well”, I thought. If it is that easy, I’ll do more:</p>{% highlight cpp %}std::vector<pplx::task<casablanca::string_t>> tasks;
for (int i = 21; i < 40; i++)
{
  cloud_table_entity signal(U("Signals_Device"), boost::lexical_cast<std::wstring>(i));
  tasks.push_back(ct.insert_entity(signal));
}

pplx::when_all(begin(tasks), end(tasks)).wait();{% endhighlight %}<p>Wowowow, quite a bit here: First I created a task vector to hold on to all insert tasks. then I start a look to create another 19 entities. For every iteration I create a new signal, with the same <strong>PartitionKey</strong> and a <strong>RowKey</strong> from the current i. Note that I threw in a little <strong>boost::lexical_cast</strong> to do the <strong>int</strong> to <strong>wstring</strong> conversion.</p><p>Every entity I create, I insert using the <strong>insert_entity</strong> method found on my <strong>cloud_table</strong> instance (ct) which returns a task, that I in turn add to my task vector. Finally, I wait using the <strong>when_all</strong> task combiner with a final wait. I know I’m not very asynchronous for now, but as that’s fine as I’m only exploring the library for now. Running the application (or VS2012 c++ unit test in my case) ran through just fine and I again viewed the table using table explorer:</p><p>
  <img src="{{site.baseurl}}/content/images/blog/2012/10/signals_table_content.PNG" class="mceC1Focused mceC1Focused mceC1Focused" />
</p><p>Not bad either, but I wanted to get one more thing done before I got on my way home: setting a property.</p><h2>Setting properties</h2><p>This one was trickier than I though, since if you didn’t specify the type of the value you are setting, you get exactly what you wanted when passing in a string: a boolean property. Anyhow, here’s what I did on the entity before saving it (Note I cleared the storage emulator a few times, to not run into “entity already present” exceptions”):</p>{% highlight cpp %}signal.set(U("SomeProperty"), U("SomeValue"), cloud_table_entity::String);{% endhighlight %}<p>just make sure you remember that 3rd parameter, or you end up with boolean properties instead of strings. I have to say, my first few steps using casablanca have been comfy and very modern c++ like. I didn’t use a single pointer dereference and I guess that is a good thing.</p><p>I also did some querying, but I’ll cover that in another blog post, stay tuned (and native!).</p>